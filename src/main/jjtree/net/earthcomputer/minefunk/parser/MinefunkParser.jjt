options
{
  STATIC = false;
  NODE_DEFAULT_VOID = true;
  MULTI = true;
  VISITOR = true;
}

PARSER_BEGIN(MinefunkParser)
package net.earthcomputer.minefunk.parser;
import java.util.*;

public class MinefunkParser
{
}

PARSER_END(MinefunkParser)

TOKEN :
{
  < NAMESPACE : "namespace" >
| < STATIC : "static" >
| < INLINE : "inline" >
| < TRUE : "true" >
| < FALSE : "false" >
| < INTLITERAL :
    (
      < PLUS >
    | < MINUS >
    )?
    (< DIGIT >)+ >
| < STRING_START : "\"" > : STATE_STRING_LITERAL
| < IDENTIFIER :
    (
      "_"
    | < LETTER >
    )
    (
      "_"
    | < ALPHANUM >
    )* >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < OPEN_BRACE : "{" >
| < CLOSE_BRACE : "}" >
| < DOUBLE_COLON : "::" >
| < COMMA : "," >
| < OPEN_PARENTHESIS : "(" >
| < CLOSE_PARENTHESIS : ")" >
| < SEMICOLON : ";" >
| < START_COMMAND : "$" > : STATE_COMMAND
}

TOKEN :
{
  < #DIGIT : [ "0"-"9" ] >
| < #LETTER : [ "a"-"z", "A"-"Z" ] >
| < #ALPHANUM :
    < DIGIT >
  | < LETTER > >
}

< STATE_STRING_LITERAL >
TOKEN :
{
  < STRING_BODY :
    (
      ~[ "\"", "\\" ]
    | "\\\\"
    | "\\\""
    )+ >
| < STRING_END : "\"" > : DEFAULT
}

< STATE_COMMAND >
TOKEN :
{
  < COMMAND_BODY :
    (
      ~[ "\r", "\n" ]
    | ("\r" ~[ "\n" ])
    )+ >
| < END_COMMAND :
    (
      "\r\n"
    | "\n"
    ) >
  : DEFAULT
}

SKIP :
{
  " "
| "\t"
| "\r\n"
| "\n"
| < LINE_COMMENT : "//" > : STATE_LINE_COMMENT
| < MULTILINE_COMMENT : "/*" > : STATE_MULTILINE_COMMENT
}

< STATE_LINE_COMMENT >
SKIP :
{
  < LINE_COMMENT_BODY :
    (
      ~[ "\r", "\n" ]
    | ("\r" ~[ "\n" ])
    )+ >
| < END_LINE_COMMENT :
    (
      "\r\n"
    | "\n"
    ) >
  : DEFAULT
}

< STATE_MULTILINE_COMMENT >
SKIP :
{
  < MULTILINE_COMMENT_BODY :
    (
      ~[ "*" ]
    | ("*" ~[ "/" ])
    )+ >
| < END_MULTILINE_COMMENT : "*/" > : DEFAULT
}

public ASTRoot parse() #Root :
{
}
{
  (
    namespace()
  )*
  < EOF >
  {
    return jjtThis;
  }
}

public void namespace() #Namespace :
{
}
{
  < NAMESPACE > 
  identifier() 
  < OPEN_BRACE >
  (
    member()
  )*
  < CLOSE_BRACE >
}

public void member() :
{
}
{
  function()
}

public void function() #Function :
{
}
{
  modifiers() 
  type() 
  identifier() 
  < OPEN_PARENTHESIS > 
  paramList() 
  < CLOSE_PARENTHESIS > 
  blockStatement()
}

public void paramList() #ParamList :
{
}
{
  (
    varDeclStatement()
    (
      < COMMA > 
      varDeclStatement()
    )*
  )?
}

public void statement() :
{
}
{
  (
    < SEMICOLON >
  | blockStatement()
  | commandStatement()
  |
    (
      LOOKAHEAD(varDeclStatement())
      varDeclStatement()
    | expressionStatement()
    )
  )
}

public void blockStatement() #BlockStmt :
{
}
{
  < OPEN_BRACE >
  (
    statement()
  )*
  < CLOSE_BRACE >
}

public void commandStatement() #CommandStmt :
{
  Token t;
}
{
  < START_COMMAND > 
  t = < COMMAND_BODY >
  {
    jjtThis.value = t.image;
  }
  < END_COMMAND >
}

public void varDeclStatement() #VarDeclStmt :
{
}
{
  modifiers() 
  type() 
  identifier()
}

public void expressionStatement() #ExpressionStmt :
{
}
{
  expression()
}

public void expression() :
{
}
{
  (
    LOOKAHEAD(functionCallExpression())
    functionCallExpression()
  | variableAccessExpression()
  )
| booleanLiteralExpression()
| integerLiteralExpression()
| stringLiteralExpression()
}

public void functionCallExpression() #FunctionCallExpr :
{
}
{
  type() 
  < OPEN_PARENTHESIS >
  (
    expression()
    (
      < COMMA > 
      expression()
    )*
  )?
  < CLOSE_PARENTHESIS >
}

public void variableAccessExpression() #VarAccessExpr :
{
}
{
  type()
}

public void booleanLiteralExpression() #BoolLiteralExpr :
{
}
{
  < TRUE >
  {
    jjtThis.value = Boolean.TRUE;
  }
| < FALSE >
  {
    jjtThis.value = Boolean.FALSE;
  }
}

public void integerLiteralExpression() #IntLiteralExpr :
{
  Token t;
}
{
  t = < INTLITERAL >
  {
    try
    {
      jjtThis.value = Integer.parseInt(t.image);
    }
    catch (NumberFormatException e)
    {
      // Possible if > Integer.MAX_VALUE or < Integer.MIN_VALUE
      throw new ParseException("Integer is out of bounds");
    }
  }
}

public void stringLiteralExpression() #StringLiteralExpr :
{
  Token t = null;
}
{
  < STRING_START > 
  (
  t = < STRING_BODY >
  )?
  {
    jjtThis.value = t == null ? "" : t.image;
  }
  < STRING_END >
}

public void identifier() #Identifier :
{
  Token t;
}
{
  t = < IDENTIFIER >
  {
    jjtThis.value = t.image;
  }
}

public void modifiers() #Modifiers :
{
  int modifiers = 0;
}
{
  (
    < STATIC >
    {
      if ((modifiers & Modifiers.STATIC) != 0)
      {
        throw new ParseException("Duplicate modifier \"static\"");
      }
      modifiers |= Modifiers.STATIC;
    }
  | < INLINE >
    {
      if ((modifiers & Modifiers.INLINE) != 0)
      {
        throw new ParseException("Duplicate modifier \"inline\"");
      }
      modifiers |= Modifiers.INLINE;
    }
  )*
}

public void type() #Type :
{
  Token t;
  List < String > namespaces = new ArrayList < String > ();
}
{
  (
    LOOKAHEAD(2)
    t = < IDENTIFIER >
    {
      namespaces.add(t.image);
    }
    < DOUBLE_COLON >
  )*
  t = < IDENTIFIER >
  {
    jjtThis.value = new Type(namespaces, t.image);
  }
}
